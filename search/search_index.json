{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"DBPlus","text":"<p>A database-agnostic Python library for unified SQL access.</p> <p>DBPlus is an interface layer between the several Python database interfaces and your program. It makes SQL access from your program database-agnostic, meaning the same code can run unmodified on several databases. All you need to change is the database URL.</p> <p>!!! warning     This software is not yet production ready and still changing. Please wait until version 1.0 for production use.</p>"},{"location":"#supported-databases","title":"Supported Databases","text":"Database Driver Package URL Scheme SQLite Built-in (no install) <code>sqlite</code> PostgreSQL <code>psycopg2</code> <code>postgres</code> MySQL <code>mysql-connector-python</code> <code>mysql</code> Oracle <code>oracledb</code> <code>oracle</code> IBM DB2 <code>ibm_db</code> <code>db2</code>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from dbplus import Database\n\n# Connect to a database\ndb = Database('sqlite:///mydata.db')\n\n# Query with named parameters\nrows = db.query('SELECT * FROM users WHERE age &gt; :age', age=21)\nfor row in rows:\n    print(row.name, row.age)\n\n# Execute statements (INSERT, UPDATE, DELETE)\naffected = db.execute('UPDATE users SET active = ? WHERE id = ?', 1, 42)\n\n# Transactions\nwith db.transaction():\n    db.execute('INSERT INTO orders VALUES (?, ?)', 1, 'Widget')\n    db.execute('UPDATE inventory SET qty = qty - 1 WHERE item = ?', 'Widget')\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Database-agnostic - Write SQL once, run on any supported database</li> <li>Unified parameter binding - Use <code>:named</code> or <code>?</code> positional parameters on all databases</li> <li>Lazy result sets - Rows are fetched on demand, not all at once</li> <li>Rich record access - Access columns by name, index, or attribute</li> <li>Transaction support - Context manager with automatic commit/rollback</li> <li>Pandas integration - Convert results directly to DataFrames</li> <li>Pydantic support - Map rows to Pydantic models</li> <li>CSV import/export - Bulk data transfer with <code>copy_to</code> and <code>copy_from</code></li> <li>SQL file management - Load named queries from <code>.sql</code> files with QueryStore</li> </ul>"},{"location":"#example-with-output","title":"Example with Output","text":"<pre><code>from dbplus import Database\n\ndb = Database('DB2://db2demo:demodb2@192.168.1.222:50000/sample')\n\nrows = db.query(\n    'SELECT * FROM emp WHERE edlevel=:edlevel AND workdept=:wd',\n    edlevel=18, wd='A00'\n)\nprint(rows)\n</code></pre> <p>Output:</p> empno firstnme midinit lastname workdept phoneno hiredate job edlevel sex birthdate salary bonus comm 000010 CHRISTINE I HAAS A00 3978 1995-01-01 PRES 18 F 1963-08-24 152750.00 1000.00 4220.00 200010 DIAN J HEMMINGER A00 3978 1995-01-01 SALESREP 18 F 1973-08-14 46500.00 1000.00 4220.00"},{"location":"connecting/","title":"Connecting to Databases","text":""},{"location":"connecting/#database-urls","title":"Database URLs","text":"<p>DBPlus uses URL-style connection strings to connect to databases. The general format is:</p> <pre><code>driver://user:password@host:port/database\n</code></pre>"},{"location":"connecting/#url-examples","title":"URL Examples","text":"<pre><code>from dbplus import Database\n\n# SQLite (local file)\ndb = Database('sqlite:///path/to/database.db')\n\n# PostgreSQL\ndb = Database('postgres://myuser:mypassword@localhost:5432/mydb')\n\n# MySQL\ndb = Database('mysql://myuser:mypassword@localhost:3306/mydb')\n\n# Oracle\ndb = Database('oracle://myuser:mypassword@localhost:1521/xe')\n\n# IBM DB2 (remote)\ndb = Database('db2://myuser:mypassword@192.168.1.100:50000/sample')\n\n# IBM DB2 (local catalog, no user/password)\ndb = Database('db2:///sample')\n</code></pre> <p>The driver name in the URL is case-insensitive (<code>sqlite</code>, <code>SQLite</code>, and <code>SQLITE</code> all work).</p>"},{"location":"connecting/#sqlite-path-formats","title":"SQLite Path Formats","text":"<p>SQLite URLs use three slashes before the path. For an absolute path, this results in four slashes on Unix-like systems:</p> <pre><code># Relative path\ndb = Database('sqlite:///mydata.db')\n\n# Absolute path (Windows)\ndb = Database('sqlite:///C:/data/mydata.db')\n\n# Absolute path (Linux/Mac)\ndb = Database('sqlite:////home/user/data/mydata.db')\n</code></pre>"},{"location":"connecting/#environment-variable","title":"Environment Variable","text":"<p>If no URL is passed to the constructor, DBPlus falls back to the <code>DATABASE_URL</code> environment variable:</p> <pre><code>import os\nos.environ['DATABASE_URL'] = 'sqlite:///mydata.db'\n\ndb = Database()  # Uses DATABASE_URL\n</code></pre>"},{"location":"connecting/#connection-lifecycle","title":"Connection Lifecycle","text":""},{"location":"connecting/#manual-management","title":"Manual Management","text":"<pre><code>db = Database('sqlite:///mydata.db')  # Opens automatically\n# ... use the database ...\ndb.close()                             # Close when done\n</code></pre>"},{"location":"connecting/#context-manager","title":"Context Manager","text":"<p>The <code>Database</code> object supports the <code>with</code> statement for automatic cleanup:</p> <pre><code>with Database('sqlite:///mydata.db') as db:\n    rows = db.query('SELECT * FROM users')\n    # ...\n# Connection is automatically closed here\n</code></pre>"},{"location":"connecting/#connection-state","title":"Connection State","text":"<pre><code>db.is_connected()    # Returns True if connected\ndb.ensure_connected()  # Reconnects if disconnected\ndb.close()           # Close the connection\ndb.open()            # Reopen a closed connection\n</code></pre>"},{"location":"connecting/#logging","title":"Logging","text":"<p>DBPlus uses Python's standard <code>logging</code> module under the logger name <code>dbplus</code>. Enable it to see connection details, SQL statements, and parameter values:</p> <pre><code>import logging\nlogging.basicConfig(level=logging.INFO)\n\ndb = Database('sqlite:///mydata.db')\n# Logs: --&gt; Using Database driver: SQLITE\n# Logs: --&gt; Database connected\n</code></pre> <p>Set <code>level=logging.DEBUG</code> for more detailed output including parameter binding and timing information.</p>"},{"location":"csv/","title":"CSV Import and Export","text":"<p>DBPlus provides built-in methods for exporting query results to CSV files and importing CSV files into database tables.</p>"},{"location":"csv/#exporting-to-csv-copy_to","title":"Exporting to CSV (<code>copy_to</code>)","text":"<p>Export a table or query result to a CSV file:</p> <pre><code>db.copy_to('output.csv', 'employees')\n</code></pre>"},{"location":"csv/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>file</code> <code>str</code> Required Output file path <code>table</code> <code>str</code> Required Table name to export <code>sep</code> <code>str</code> <code>\\t</code> Field separator (delimiter) <code>null</code> <code>str</code> <code>\\x00</code> String to represent NULL values <code>columns</code> <code>list</code> <code>None</code> List of column names (default: all <code>*</code>) <code>header</code> <code>bool</code> <code>False</code> Write column names as the first row <code>append</code> <code>bool</code> <code>False</code> Append to file instead of overwriting <code>recsep</code> <code>str</code> <code>\\n</code> Record separator (line ending)"},{"location":"csv/#return-value","title":"Return Value","text":"<p>Returns the number of rows written.</p>"},{"location":"csv/#examples","title":"Examples","text":"<pre><code># Basic export (tab-separated, no header)\nrows_written = db.copy_to('employees.tsv', 'employees')\nprint(f'{rows_written} rows exported')\n\n# CSV with header\ndb.copy_to('employees.csv', 'employees', sep=',', header=True)\n\n# Export specific columns\ndb.copy_to('names.csv', 'employees', sep=',', header=True,\n           columns=['firstname', 'lastname', 'email'])\n\n# Append to existing file\ndb.copy_to('all_data.csv', 'employees', sep=',', append=True)\n\n# Custom NULL representation\ndb.copy_to('data.csv', 'employees', sep=',', null='NULL')\n</code></pre>"},{"location":"csv/#importing-from-csv-copy_from","title":"Importing from CSV (<code>copy_from</code>)","text":"<p>Import data from a CSV file into a database table:</p> <pre><code>db.copy_from('data.csv', 'employees')\n</code></pre>"},{"location":"csv/#parameters_1","title":"Parameters","text":"Parameter Type Default Description <code>file</code> <code>str</code> Required Input file path <code>table</code> <code>str</code> Required Target table name <code>sep</code> <code>str</code> <code>\\t</code> Field separator (delimiter) <code>recsep</code> <code>str</code> <code>\\n</code> Record separator (line ending) <code>header</code> <code>bool</code> <code>False</code> Skip the first row (header line) <code>null</code> <code>str</code> <code>\\x00</code> String that represents NULL values <code>batch</code> <code>int</code> <code>500</code> Number of rows to insert per batch <code>columns</code> <code>list</code> <code>None</code> List of target column names"},{"location":"csv/#return-value_1","title":"Return Value","text":"<p>Returns the number of rows read from the file.</p>"},{"location":"csv/#examples_1","title":"Examples","text":"<pre><code># Basic import (tab-separated, no header)\nrows_read = db.copy_from('employees.tsv', 'employees')\nprint(f'{rows_read} rows imported')\n\n# CSV with header row\ndb.copy_from('employees.csv', 'employees', sep=',', header=True)\n\n# Import into specific columns\ndb.copy_from('names.csv', 'employees', sep=',', header=True,\n             columns=['firstname', 'lastname', 'email'])\n\n# Adjust batch size for large files\ndb.copy_from('large_data.csv', 'employees', sep=',', batch=1000)\n\n# Custom NULL handling\ndb.copy_from('data.csv', 'employees', sep=',', null='NULL')\n</code></pre>"},{"location":"csv/#batch-processing","title":"Batch Processing","text":"<p>The <code>copy_from</code> method inserts rows in batches (default 500 rows per batch) for performance. Each batch is a single <code>INSERT ... VALUES</code> statement with multiple rows. Adjust the <code>batch</code> parameter based on your data and database:</p> <pre><code># Smaller batches for rows with many columns or large values\ndb.copy_from('wide_table.csv', 'wide_table', batch=100)\n\n# Larger batches for simple data\ndb.copy_from('simple_data.csv', 'simple_table', batch=2000)\n</code></pre>"},{"location":"csv/#round-trip-example","title":"Round-Trip Example","text":"<p>Export from one database and import into another:</p> <pre><code>from dbplus import Database\n\n# Export from source\nsource = Database('db2://user:pass@host1:50000/production')\nsource.copy_to('employees.csv', 'employees', sep=',', header=True)\nsource.close()\n\n# Import into target\ntarget = Database('postgres://user:pass@host2:5432/staging')\ntarget.copy_from('employees.csv', 'employees', sep=',', header=True)\ntarget.close()\n</code></pre>"},{"location":"drivers/","title":"Database Drivers","text":"<p>Each database backend is implemented as a driver module in <code>dbplus/drivers/</code>. All drivers implement the same <code>BaseDriver</code> interface, ensuring consistent behavior across databases.</p>"},{"location":"drivers/#driver-selection","title":"Driver Selection","text":"<p>The driver is selected automatically based on the URL scheme. The scheme name (case-insensitive) maps directly to the driver module:</p> URL Scheme Driver Module Native Library Placeholder <code>sqlite</code> <code>SQLITE.py</code> <code>sqlite3</code> (built-in) <code>?</code> <code>postgres</code> <code>POSTGRES.py</code> <code>psycopg2</code> <code>%s</code> <code>mysql</code> <code>MYSQL.py</code> <code>mysql.connector</code> <code>%s</code> <code>oracle</code> <code>ORACLE.py</code> <code>oracledb</code> <code>:</code> <code>db2</code> <code>DB2.py</code> <code>ibm_db</code> <code>?</code> <p>You never need to work with placeholders directly. DBPlus's <code>Statement</code> class automatically translates your <code>:named</code> and <code>?</code> positional parameters into the appropriate driver placeholder.</p>"},{"location":"drivers/#accessing-the-driver","title":"Accessing the Driver","text":"<p>You can access the underlying driver object for driver-specific functionality:</p> <pre><code>driver = db.get_driver()\n</code></pre> <p>Additionally, <code>Database</code> proxies unknown method calls to the driver, so you can call driver-specific methods directly on the <code>Database</code> object:</p> <pre><code># DB2-specific: get server information\ninfo = db.get_server_info()\nprint(info.DB_NAME)\n\n# DB2-specific: list columns\ncols = db.columns(None, '%', 'EMPLOYEES', '')\nprint(cols)\n</code></pre>"},{"location":"drivers/#sqlite","title":"SQLite","text":"<p>Library: <code>sqlite3</code> (built-in)</p> <p>Connection URL:</p> <pre><code>sqlite:///path/to/database.db\n</code></pre> <p>SQLite is the simplest driver to use since it requires no additional installation. The database is a local file.</p> <p>Features:</p> <ul> <li>Autocommit mode is enabled by default</li> <li>Row factory produces dictionary-style rows</li> <li>Supports <code>last_insert_id()</code> via <code>lastrowid</code></li> </ul> <p>Default port: N/A (file-based)</p>"},{"location":"drivers/#postgresql","title":"PostgreSQL","text":"<p>Library: <code>psycopg2</code></p> <p>Connection URL:</p> <pre><code>postgres://user:password@host:port/database\n</code></pre> <p>Features:</p> <ul> <li>Cursor-based row fetching</li> <li><code>bytearray</code> values are automatically decoded to UTF-8 strings</li> <li>Supports <code>callproc()</code> for stored procedures</li> </ul> <p>Default port: 5432</p>"},{"location":"drivers/#mysql","title":"MySQL","text":"<p>Library: <code>mysql-connector-python</code></p> <p>Connection URL:</p> <pre><code>mysql://user:password@host:port/database\n</code></pre> <p>Features:</p> <ul> <li>Detailed connection error messages (access denied, database not found)</li> <li><code>bytearray</code> values are automatically decoded to UTF-8 strings</li> <li>Supports <code>callproc()</code> for stored procedures</li> </ul> <p>Default port: 3306</p>"},{"location":"drivers/#oracle","title":"Oracle","text":"<p>Library: <code>oracledb</code></p> <p>Connection URL:</p> <pre><code>oracle://user:password@host:port/service_name\n</code></pre> <p>Features:</p> <ul> <li>Uses native <code>:param</code> binding (kwargs passed directly to Oracle)</li> <li>DSN format: <code>host:port/service_name</code></li> <li>Supports <code>callproc()</code> for stored procedures</li> </ul> <p>Default port: 1521</p> <p>!!! note     Oracle uses <code>:param</code> placeholders natively, so named parameters are passed directly to the Oracle driver without rewriting. This means Oracle queries must use <code>:param</code> style exclusively.</p>"},{"location":"drivers/#ibm-db2","title":"IBM DB2","text":"<p>Library: <code>ibm_db</code></p> <p>Connection URL:</p> <pre><code>db2://user:password@host:port/database\n</code></pre> <p>For a local cataloged database (no authentication):</p> <pre><code>db2:///database_name\n</code></pre> <p>Features:</p> <ul> <li>Persistent connections via <code>ibm_db.pconnect()</code></li> <li>Column names returned in lowercase (<code>ATTR_CASE: CASE_LOWER</code>)</li> <li><code>last_insert_id()</code> via <code>IDENTITY_VAL_LOCAL()</code></li> <li><code>callproc()</code> with multiple result sets (<code>next_result()</code>)</li> <li><code>columns()</code> for table introspection</li> <li><code>get_server_info()</code> for database server metadata</li> <li><code>execute_many()</code> for batch inserts</li> <li><code>describe_cursor()</code> for detailed column metadata</li> <li>Windows <code>clidriver</code> DLL auto-detection</li> </ul> <p>Default port: 50000</p> <p>DB2-specific methods available on the Database object:</p> <pre><code>db = Database('db2://user:pass@host:50000/sample')\n\n# Server information\ninfo = db.get_server_info()\nprint(info.DB_NAME, info.DBMS_VER)\n\n# Table column information\ncols = db.columns(None, 'SCHEMA', 'TABLE_NAME', '')\nfor col in cols:\n    print(col.column_name, col.type_name)\n</code></pre>"},{"location":"drivers/#connection-string-formats","title":"Connection String Formats","text":""},{"location":"drivers/#db2-remote-connection","title":"DB2 Remote Connection","text":"<p>For remote DB2 connections, the driver builds a connection string:</p> <pre><code>DATABASE=sample;UID=user;PWD=pass;HOSTNAME=192.168.1.100;PORT=50000;PROTOCOL=TCPIP;\n</code></pre>"},{"location":"drivers/#db2-local-cataloged-connection","title":"DB2 Local (Cataloged) Connection","text":"<p>For local connections (where host is <code>localhost</code> or omitted), the driver uses DSN format:</p> <pre><code>DSN=sample;UID=;PWD=;\n</code></pre>"},{"location":"executing/","title":"Executing Statements","text":""},{"location":"executing/#the-execute-method","title":"The <code>execute()</code> Method","text":"<p>Use <code>db.execute()</code> for SQL statements that modify data: INSERT, UPDATE, DELETE, and DDL statements. It returns the number of affected rows.</p> <pre><code># INSERT\ndb.execute('INSERT INTO users (name, age) VALUES (?, ?)', 'Alice', 30)\n\n# UPDATE - returns number of rows updated\nupdated = db.execute('UPDATE users SET active = ? WHERE age &lt; ?', 0, 18)\nprint(f'{updated} users deactivated')\n\n# DELETE - returns number of rows deleted\ndeleted = db.execute('DELETE FROM users WHERE active = ?', 0)\nprint(f'{deleted} users deleted')\n</code></pre>"},{"location":"executing/#named-parameters","title":"Named Parameters","text":"<pre><code>db.execute(\n    'INSERT INTO users (name, email) VALUES (:name, :email)',\n    name='Alice',\n    email='alice@example.com'\n)\n</code></pre>"},{"location":"executing/#positional-parameters","title":"Positional Parameters","text":"<pre><code>db.execute(\n    'INSERT INTO users (name, email) VALUES (?, ?)',\n    'Alice',\n    'alice@example.com'\n)\n</code></pre>"},{"location":"executing/#transactions","title":"Transactions","text":""},{"location":"executing/#context-manager-recommended","title":"Context Manager (Recommended)","text":"<p>The <code>transaction()</code> context manager automatically commits on success and rolls back on any exception:</p> <pre><code>with db.transaction():\n    db.execute('DELETE FROM order_items WHERE order_id = ?', order_id)\n    db.execute('DELETE FROM orders WHERE id = ?', order_id)\n    db.execute('UPDATE inventory SET qty = qty + ? WHERE item_id = ?', qty, item_id)\n# Committed automatically when the block exits normally\n</code></pre> <p>If an exception occurs inside the block, the transaction is rolled back and the exception is re-raised:</p> <pre><code>try:\n    with db.transaction():\n        db.execute('INSERT INTO accounts VALUES (?, ?)', 1, 1000)\n        raise ValueError('Something went wrong')\n        # This line is never reached\nexcept ValueError:\n    # Transaction was rolled back\n    pass\n</code></pre>"},{"location":"executing/#manual-transaction-control","title":"Manual Transaction Control","text":"<p>You can also manage transactions manually:</p> <pre><code>db.begin_transaction()\ntry:\n    db.execute('INSERT INTO orders VALUES (?, ?)', 1, 'Widget')\n    db.execute('UPDATE inventory SET qty = qty - 1 WHERE item = ?', 'Widget')\n    db.commit()\nexcept Exception:\n    db.rollback()\n    raise\n</code></pre>"},{"location":"executing/#transaction-rules","title":"Transaction Rules","text":"<ul> <li>No nesting: Starting a transaction while one is already active raises <code>DBError</code></li> <li>No manual commit/rollback inside context manager: Calling <code>db.commit()</code> or <code>db.rollback()</code> inside a <code>with db.transaction()</code> block raises <code>DBError</code></li> <li>Check state: Use <code>db.is_transaction_active()</code> to check if a transaction is in progress</li> </ul> <pre><code># This raises DBError:\nwith db.transaction():\n    db.commit()  # Error! Cannot commit inside transaction block\n\n# This also raises DBError:\nwith db.transaction():\n    with db.transaction():  # Error! Nested transactions not supported\n        pass\n</code></pre>"},{"location":"executing/#stored-procedures","title":"Stored Procedures","text":"<p>Call stored procedures with <code>db.callproc()</code>. It returns a tuple of <code>(RecordCollection, *output_params)</code>:</p> <pre><code># Call a stored procedure with parameters\nresult, *output = db.callproc('find_employee', ['000010', ''])\nprint(result)           # RecordCollection with result set\nprint(output)           # Output parameter values\n\n# Procedure with no output\nresult = db.callproc('update_stats')\n</code></pre>"},{"location":"executing/#multiple-result-sets","title":"Multiple Result Sets","text":"<p>Some stored procedures return multiple result sets. Use <code>next_result()</code> on the <code>RecordCollection</code> to access subsequent result sets:</p> <pre><code>result, *params = db.callproc('read_emp_dept')\nprint(result)                       # First result set\n\nnext_rs = result.next_result()      # Advance to second result set\nprint(next_rs)\n</code></pre>"},{"location":"executing/#last-insert-id","title":"Last Insert ID","text":"<p>After an INSERT into a table with an auto-increment or identity column, retrieve the generated ID:</p> <pre><code>db.execute('INSERT INTO users (name) VALUES (?)', 'Alice')\nnew_id = db.last_insert_id()\nprint(f'New user ID: {new_id}')\n</code></pre> <p>For DB2, this uses <code>IDENTITY_VAL_LOCAL()</code>. For SQLite, it uses the cursor's <code>lastrowid</code> attribute.</p>"},{"location":"executing/#error-handling","title":"Error Handling","text":"<p>DBPlus raises specific exceptions for different error conditions:</p> <pre><code>from dbplus import Database, DBError\n\ntry:\n    db = Database('sqlite:///mydata.db')\n    db.execute('INSERT INTO nonexistent VALUES (?)', 1)\nexcept RuntimeError as e:\n    print(f'SQL error: {e}')\nexcept DBError as e:\n    print(f'DBPlus error: {e}')\nexcept ValueError as e:\n    print(f'Connection error: {e}')\n</code></pre> <ul> <li><code>ValueError</code> - Invalid database URL or driver initialization failure</li> <li><code>RuntimeError</code> - SQL execution errors (bad SQL, constraint violations, etc.)</li> <li><code>DBError</code> - Transaction logic errors (nested transactions, improper commit/rollback)</li> <li><code>LookupError</code> - Missing parameter in SQL binding (named or positional parameter not found)</li> </ul> <p>You can also inspect the last error from the driver:</p> <pre><code>print(db.error_code())  # Driver-specific error code\nprint(db.error_info())  # Driver-specific error message\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installing-dbplus","title":"Installing DBPlus","text":"<p>From PyPI:</p> <pre><code>pip install dbplus\n</code></pre> <p>From GitHub:</p> <pre><code>git clone https://github.com/klaasbrant/DBPlus.git\ncd DBPlus\npip install .\n</code></pre>"},{"location":"installation/#installing-database-drivers","title":"Installing Database Drivers","text":"<p>DBPlus has no required dependencies. You only need to install the driver for the database(s) you intend to use.</p>"},{"location":"installation/#sqlite","title":"SQLite","text":"<p>No installation required. SQLite support is built into Python via the <code>sqlite3</code> module.</p>"},{"location":"installation/#postgresql","title":"PostgreSQL","text":"<pre><code>pip install psycopg2\n</code></pre> <p>Or the binary-only package (no C compiler needed):</p> <pre><code>pip install psycopg2-binary\n</code></pre>"},{"location":"installation/#mysql","title":"MySQL","text":"<pre><code>pip install mysql-connector-python\n</code></pre>"},{"location":"installation/#oracle","title":"Oracle","text":"<pre><code>pip install oracledb\n</code></pre>"},{"location":"installation/#ibm-db2","title":"IBM DB2","text":"<pre><code>pip install ibm_db\n</code></pre> <p>!!! note \"Windows users\"     On Windows, DBPlus automatically locates the <code>clidriver/bin</code> directory required by <code>ibm_db</code>. It checks the <code>IBM_DB_HOME</code> environment variable first, then searches Python's <code>site-packages</code> directory. If neither is found, a <code>FileNotFoundError</code> is raised.</p>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>These are not required but enable additional features:</p> Package Feature <code>pandas</code> <code>RecordCollection.as_DataFrame()</code> conversion <code>pydantic</code> <code>Record.as_model()</code> and <code>RecordCollection.as_model()</code> conversion"},{"location":"queries/","title":"Querying Data","text":""},{"location":"queries/#the-query-method","title":"The <code>query()</code> Method","text":"<p>Use <code>db.query()</code> to execute SELECT statements. It returns a <code>RecordCollection</code> containing the result rows.</p> <pre><code>rows = db.query('SELECT * FROM employees')\n</code></pre>"},{"location":"queries/#parameter-binding","title":"Parameter Binding","text":"<p>DBPlus provides a unified parameter syntax that works across all database backends. You never need to worry about whether your database uses <code>?</code>, <code>%s</code>, or <code>:param</code> natively.</p>"},{"location":"queries/#named-parameters","title":"Named Parameters","text":"<p>Use <code>:param_name</code> syntax to bind keyword arguments:</p> <pre><code>rows = db.query(\n    'SELECT * FROM employees WHERE department = :dept AND salary &gt; :min_salary',\n    dept='Engineering',\n    min_salary=50000\n)\n</code></pre>"},{"location":"queries/#positional-parameters","title":"Positional Parameters","text":"<p>Use <code>?</code> to bind positional arguments:</p> <pre><code>rows = db.query(\n    'SELECT * FROM employees WHERE department = ? AND salary &gt; ?',\n    'Engineering',\n    50000\n)\n</code></pre>"},{"location":"queries/#listtuple-expansion","title":"List/Tuple Expansion","text":"<p>Lists and tuples are automatically expanded into comma-separated placeholders, making <code>IN</code> clauses easy:</p> <pre><code>rows = db.query(\n    'SELECT * FROM employees WHERE department IN (:depts)',\n    depts=['Engineering', 'Sales', 'Marketing']\n)\n# Expands to: WHERE department IN (?, ?, ?)\n</code></pre>"},{"location":"queries/#dictionary-parameters","title":"Dictionary Parameters","text":"<p>You can pass a dictionary as a positional argument to provide named parameters:</p> <pre><code>params = {'dept': 'Engineering', 'min_salary': 50000}\nrows = db.query(\n    'SELECT * FROM employees WHERE department = :dept AND salary &gt; :min_salary',\n    params\n)\n</code></pre>"},{"location":"queries/#working-with-results","title":"Working with Results","text":""},{"location":"queries/#iteration","title":"Iteration","text":"<p><code>RecordCollection</code> is iterable. Rows are fetched lazily from the database cursor:</p> <pre><code>rows = db.query('SELECT * FROM employees')\nfor row in rows:\n    print(row.firstname, row.lastname)\n</code></pre>"},{"location":"queries/#indexing-and-slicing","title":"Indexing and Slicing","text":"<p>Access individual rows by index, or get a subset with slicing:</p> <pre><code>rows = db.query('SELECT * FROM employees')\n\nfirst = rows[0]        # First row\nlast = rows[-1]        # Last row (fetches all rows)\nsubset = rows[2:5]     # Rows 2, 3, 4 (returns a new RecordCollection)\n</code></pre>"},{"location":"queries/#length","title":"Length","text":"<pre><code>rows = db.query('SELECT * FROM employees')\nprint(len(rows))  # Number of rows fetched so far\nrows.all()         # Fetch all remaining rows\nprint(len(rows))  # Total number of rows\n</code></pre> <p>!!! note     <code>len()</code> returns the count of rows fetched so far, not the total result set size. Call <code>rows.all()</code> first if you need the complete count.</p>"},{"location":"queries/#fetching-all-rows","title":"Fetching All Rows","text":"<p>The <code>all()</code> method fetches all remaining rows and returns them as a list:</p> <pre><code>rows = db.query('SELECT * FROM employees')\n\nall_records = rows.all()                # List of Record objects\nall_dicts = rows.all(as_dict=True)      # List of dictionaries\nall_tuples = rows.all(as_tuple=True)    # List of tuples\nall_json = rows.all(as_json=True)       # List of JSON strings\n</code></pre>"},{"location":"queries/#single-row","title":"Single Row","text":"<p>Use <code>one()</code> to get just the first row, with an optional default:</p> <pre><code>row = db.query('SELECT * FROM employees WHERE id = ?', 42).one()\nif row:\n    print(row.name)\n\n# With a default value\nrow = db.query('SELECT * FROM employees WHERE id = ?', 999).one(default=None)\n</code></pre>"},{"location":"queries/#scalar-value","title":"Scalar Value","text":"<p>Use <code>scalar()</code> to get the first column of the first row - ideal for <code>COUNT(*)</code> and similar queries:</p> <pre><code>count = db.query('SELECT COUNT(*) FROM employees').scalar()\nprint(f'There are {count} employees')\n\n# With a default\nmax_salary = db.query('SELECT MAX(salary) FROM employees WHERE dept = ?', 'XYZ').scalar(default=0)\n</code></pre>"},{"location":"queries/#printing-results","title":"Printing Results","text":"<p><code>RecordCollection</code> has a built-in table formatter. Just print it or convert it to a string:</p> <pre><code>rows = db.query('SELECT empno, firstname, lastname FROM employees')\nprint(rows)\n</code></pre> <p>Output:</p> <pre><code>empno |firstname|lastname\n------|---------|--------\n000010|CHRISTINE|HAAS\n000020|MICHAEL  |THOMPSON\n</code></pre>"},{"location":"queries/#conversion-methods","title":"Conversion Methods","text":""},{"location":"queries/#to-dictionaries","title":"To Dictionaries","text":"<pre><code>rows = db.query('SELECT * FROM employees')\nlist_of_dicts = rows.as_dict()\n# [{'empno': '000010', 'firstname': 'CHRISTINE', ...}, ...]\n</code></pre>"},{"location":"queries/#to-tuples","title":"To Tuples","text":"<pre><code>rows = db.query('SELECT * FROM employees')\nlist_of_tuples = rows.as_tuple()\n# [('000010', 'CHRISTINE', ...), ...]\n</code></pre>"},{"location":"queries/#to-json","title":"To JSON","text":"<pre><code>rows = db.query('SELECT * FROM employees')\nlist_of_json = rows.as_json()\n# ['{\"empno\": \"000010\", \"firstname\": \"CHRISTINE\", ...}', ...]\n</code></pre>"},{"location":"queries/#to-pandas-dataframe","title":"To Pandas DataFrame","text":"<p>Requires <code>pandas</code> to be installed:</p> <pre><code>rows = db.query('SELECT * FROM employees')\ndf = rows.as_DataFrame()\nprint(df.to_csv())\n</code></pre>"},{"location":"queries/#to-pydantic-models","title":"To Pydantic Models","text":"<p>Requires <code>pydantic</code> to be installed:</p> <pre><code>from pydantic import BaseModel\n\nclass Employee(BaseModel):\n    firstnme: str\n    lastname: str\n\nrows = db.query('SELECT firstnme, lastname FROM employees')\n\n# Single row\nemp = rows[0].as_model(Employee)\nprint(emp.firstnme, emp.lastname)\n\n# All rows\nemployees = rows.as_model(Employee)\nfor emp in employees:\n    print(emp.firstnme, emp.lastname)\n</code></pre>"},{"location":"queries/#result-metadata","title":"Result Metadata","text":"<p>Access cursor description information (column names, types, etc.) via the <code>description</code> property:</p> <pre><code>rows = db.query('SELECT * FROM employees')\nprint(rows.description)\n</code></pre>"},{"location":"queries/#pending-state","title":"Pending State","text":"<p>A <code>RecordCollection</code> tracks whether all rows have been fetched from the database cursor:</p> <pre><code>rows = db.query('SELECT * FROM employees')\nprint(rows.pending)  # True - rows not yet fully fetched\n\nrows.all()\nprint(rows.pending)  # False - all rows fetched\n</code></pre>"},{"location":"queries/#multiple-result-sets","title":"Multiple Result Sets","text":"<p>Some stored procedures return multiple result sets. Use <code>next_result()</code> to advance to the next one:</p> <pre><code>result, params = db.callproc('my_procedure')\nprint(result)                    # First result set\n\nnext_rs = result.next_result()   # Second result set\nprint(next_rs)\n</code></pre>"},{"location":"querystore/","title":"QueryStore","text":"<p>The <code>QueryStore</code> class lets you organize SQL queries in external <code>.sql</code> files and load them by name. This keeps SQL out of your Python code and makes queries easier to manage.</p>"},{"location":"querystore/#sql-file-format","title":"SQL File Format","text":"<p>Queries are defined in <code>.sql</code> files using <code>-- name:</code> comments to mark each query:</p> <pre><code>-- name: get-all-employees\n-- Retrieve all employees from the database\nSELECT *\nFROM employees\n\n-- name: get-employee-by-id\n-- Find a specific employee by their ID\nSELECT *\nFROM employees\nWHERE empno = :empno\n\n-- name: active-employees-in-dept\n-- Get active employees in a department\nSELECT firstname, lastname, salary\nFROM employees\nWHERE workdept = :dept\n  AND status = 'ACTIVE'\n</code></pre> <p>Each query definition consists of:</p> <ol> <li><code>-- name: query_name</code> - The query name (required). Hyphens are converted to underscores.</li> <li><code>-- comment text</code> - Optional description comments (any SQL comments after the name line)</li> <li>The SQL statement itself (everything until the next <code>-- name:</code> or end of file)</li> </ol>"},{"location":"querystore/#loading-queries","title":"Loading Queries","text":""},{"location":"querystore/#from-a-single-file","title":"From a Single File","text":"<pre><code>from dbplus import QueryStore\n\nQ = QueryStore('path/to/queries.sql')\n</code></pre>"},{"location":"querystore/#from-a-directory","title":"From a Directory","text":"<p>When loading from a directory, all <code>.sql</code> files are loaded recursively:</p> <pre><code>Q = QueryStore('path/to/sql/')\n</code></pre> <p>Files in subdirectories get their query names prefixed with the file stem to avoid name conflicts. For example, a query named <code>get_all</code> in <code>reports/sales.sql</code> becomes <code>sales_get_all</code>.</p>"},{"location":"querystore/#file-extension-filter","title":"File Extension Filter","text":"<p>By default, only <code>.sql</code> files are loaded. Change this with the <code>ext</code> parameter:</p> <pre><code>Q = QueryStore('path/to/sql/', ext=('.sql', '.query'))\n</code></pre>"},{"location":"querystore/#name-prefixing","title":"Name Prefixing","text":"<p>Control whether file names are used as prefixes for query names:</p> <pre><code># No prefix (default for single files)\nQ = QueryStore('queries.sql', prefix=False)\n\n# Force prefix with file stem\nQ = QueryStore('queries.sql', prefix=True)\n# Query \"get_all\" in \"reports.sql\" becomes \"reports_get_all\"\n</code></pre>"},{"location":"querystore/#using-queries","title":"Using Queries","text":"<p>Access loaded queries as attributes on the <code>QueryStore</code> object:</p> <pre><code>Q = QueryStore('queries.sql')\n\n# Access query by attribute name (hyphens become underscores)\nrows = db.query(Q.get_all_employees)\nrows = db.query(Q.get_employee_by_id, empno='000010')\n</code></pre> <p>The attribute returns a <code>Query</code> named tuple that can be passed directly to <code>db.query()</code> or <code>db.execute()</code>.</p>"},{"location":"querystore/#the-query-object","title":"The Query Object","text":"<p>Each loaded query is a <code>Query</code> named tuple with these fields:</p> Field Type Description <code>name</code> <code>str</code> The query name <code>comments</code> <code>str</code> Description from SQL comments <code>sql</code> <code>str</code> The SQL statement <code>floc</code> <code>(Path, int)</code> or <code>None</code> Source file path and line number <pre><code>Q = QueryStore('queries.sql')\n\nprint(Q.get_all_employees.name)       # 'get_all_employees'\nprint(Q.get_all_employees.comments)   # 'Retrieve all employees from the database'\nprint(Q.get_all_employees.sql)        # 'SELECT * FROM employees'\nprint(Q.get_all_employees.floc)       # (PosixPath('queries.sql'), 2)\n</code></pre>"},{"location":"querystore/#listing-all-queries","title":"Listing All Queries","text":"<p>Iterate over the <code>query_store</code> dictionary to see all loaded queries:</p> <pre><code>Q = QueryStore('path/to/sql/')\n\nfor name, query in Q.query_store.items():\n    print(f'{name}: {query.sql} (from {query.floc})')\n</code></pre>"},{"location":"querystore/#duplicate-detection","title":"Duplicate Detection","text":"<p>If two queries have the same name (after prefix and hyphen-to-underscore conversion), a <code>SQLLoadException</code> is raised:</p> <pre><code># This raises SQLLoadException if any query names collide\nQ = QueryStore('path/to/sql/')\n</code></pre>"},{"location":"querystore/#exceptions","title":"Exceptions","text":"Exception Description <code>SQLLoadException</code> File/directory not found, or duplicate query name <code>SQLParseException</code> Invalid query name format <p>Query names must start with a letter or underscore (not a digit) and contain only word characters.</p>"},{"location":"querystore/#complete-example","title":"Complete Example","text":"<p>File: <code>queries/employees.sql</code></p> <pre><code>-- name: get-emp\n-- Get employees by education level and department\nSELECT * FROM emp\nWHERE edlevel = :edlevel AND workdept = :wd\n\n-- name: count-by-dept\n-- Count employees per department\nSELECT workdept, COUNT(*) as cnt\nFROM emp\nGROUP BY workdept\n</code></pre> <p>Python code:</p> <pre><code>from dbplus import Database, QueryStore\n\ndb = Database('db2://user:pass@host:50000/sample')\nQ = QueryStore('queries/employees.sql')\n\n# Use loaded queries\nrows = db.query(Q.get_emp, edlevel=18, wd='A00')\nprint(rows)\n\ncount = db.query(Q.count_by_dept)\nprint(count.as_DataFrame())\n</code></pre>"},{"location":"records/","title":"Record and RecordCollection","text":""},{"location":"records/#record","title":"Record","text":"<p>A <code>Record</code> represents a single row from a query result. It provides multiple ways to access column values.</p>"},{"location":"records/#accessing-values","title":"Accessing Values","text":"<pre><code>row = db.query('SELECT empno, firstname, lastname FROM employees').one()\n\n# By column name (dictionary-style)\nprint(row['firstname'])\n\n# By attribute\nprint(row.firstname)\n\n# By column index (0-based)\nprint(row[0])  # empno\nprint(row[1])  # firstname\n\n# With a default value\nprint(row.get('middle_name', 'N/A'))\n</code></pre>"},{"location":"records/#getting-keys-and-values","title":"Getting Keys and Values","text":"<pre><code>row = db.query('SELECT empno, firstname, lastname FROM employees').one()\n\nprint(row.keys())    # ['empno', 'firstname', 'lastname']\nprint(row.values())  # ['000010', 'CHRISTINE', 'HAAS']\n</code></pre>"},{"location":"records/#conversion-methods","title":"Conversion Methods","text":"<pre><code>row = db.query('SELECT empno, firstname FROM employees').one()\n\n# To dictionary\nd = row.as_dict()\n# {'empno': '000010', 'firstname': 'CHRISTINE'}\n\n# To tuple\nt = row.as_tuple()\n# ('000010', 'CHRISTINE')\n\n# To list\nl = row.as_list()\n# ['000010', 'CHRISTINE']\n\n# To JSON string\nj = row.as_json()\n# '{\"empno\": \"000010\", \"firstname\": \"CHRISTINE\"}'\n\n# To JSON with formatting options\nj = row.as_json(indent=2)\n</code></pre>"},{"location":"records/#pydantic-model-conversion","title":"Pydantic Model Conversion","text":"<p>Map a record to a Pydantic model:</p> <pre><code>from pydantic import BaseModel\n\nclass Employee(BaseModel):\n    empno: str\n    firstname: str\n    lastname: str\n\nrow = db.query('SELECT empno, firstname, lastname FROM employees').one()\nemp = row.as_model(Employee)\nprint(emp.firstname)  # CHRISTINE\n</code></pre> <p>The <code>as_model()</code> method also works with Python dataclasses or any class that accepts keyword arguments in its constructor.</p>"},{"location":"records/#string-representation","title":"String Representation","text":"<pre><code>row = db.query('SELECT empno, firstname FROM employees').one()\nprint(row)\n# &lt;Record {\"empno\": \"000010\", \"firstname\": \"CHRISTINE\"}&gt;\n</code></pre>"},{"location":"records/#recordcollection","title":"RecordCollection","text":"<p>A <code>RecordCollection</code> is a lazy container of <code>Record</code> objects returned by <code>db.query()</code>. Rows are fetched from the database cursor on demand.</p>"},{"location":"records/#lazy-evaluation","title":"Lazy Evaluation","text":"<p>Rows are only fetched when accessed. This means you can start processing results before the entire query has completed:</p> <pre><code>rows = db.query('SELECT * FROM large_table')\n# No rows fetched yet\n\nfirst = rows[0]    # Fetches the first row\n# Only one row fetched\n\nfor row in rows:   # Fetches remaining rows one by one\n    process(row)\n</code></pre>"},{"location":"records/#iteration","title":"Iteration","text":"<pre><code>rows = db.query('SELECT * FROM employees')\nfor row in rows:\n    print(row.firstname, row.lastname)\n</code></pre>"},{"location":"records/#indexing","title":"Indexing","text":"<pre><code>rows = db.query('SELECT * FROM employees')\n\nfirst = rows[0]     # First row\nthird = rows[2]     # Third row\nlast = rows[-1]     # Last row (requires fetching all rows)\n</code></pre>"},{"location":"records/#slicing","title":"Slicing","text":"<p>Slicing returns a new <code>RecordCollection</code>:</p> <pre><code>rows = db.query('SELECT * FROM employees')\n\nfirst_five = rows[0:5]     # First 5 rows\nfrom_third = rows[2:]      # From third row onward (fetches all)\nlast_three = rows[-3:]     # Last 3 rows (fetches all)\n\nfor row in first_five:\n    print(row.firstname)\n</code></pre>"},{"location":"records/#length","title":"Length","text":"<pre><code>rows = db.query('SELECT * FROM employees')\n\n# len() returns count of rows fetched so far\nprint(len(rows))  # 0 (nothing fetched yet)\n\nrows.all()\nprint(len(rows))  # Total row count\n</code></pre>"},{"location":"records/#bulk-conversion","title":"Bulk Conversion","text":"<pre><code>rows = db.query('SELECT * FROM employees')\n\n# All as Record objects\nrecords = rows.all()\n\n# All as dictionaries\ndicts = rows.all(as_dict=True)\n# or: dicts = rows.as_dict()\n\n# All as tuples\ntuples = rows.all(as_tuple=True)\n# or: tuples = rows.as_tuple()\n\n# All as JSON strings\njson_list = rows.all(as_json=True)\n# or: json_list = rows.as_json()\n</code></pre>"},{"location":"records/#dataframe-conversion","title":"DataFrame Conversion","text":"<p>Convert the entire result set to a Pandas DataFrame:</p> <pre><code>rows = db.query('SELECT * FROM employees')\ndf = rows.as_DataFrame()\n\n# Use any Pandas operations\nprint(df.describe())\nprint(df.to_csv())\nprint(df.groupby('department').mean())\n</code></pre> <p>Requires <code>pandas</code> to be installed. Raises <code>NotImplementedError</code> with an installation hint if Pandas is missing.</p>"},{"location":"records/#pydantic-model-conversion_1","title":"Pydantic Model Conversion","text":"<p>Convert all rows to a list of Pydantic model instances:</p> <pre><code>from pydantic import BaseModel\n\nclass Employee(BaseModel):\n    firstnme: str\n    lastname: str\n\nrows = db.query('SELECT firstnme, lastname FROM employees')\nemployees = rows.as_model(Employee)\n\nfor emp in employees:\n    print(f'{emp.firstnme} {emp.lastname}')\n</code></pre>"},{"location":"records/#convenience-methods","title":"Convenience Methods","text":""},{"location":"records/#onedefaultnone","title":"<code>one(default=None)</code>","text":"<p>Returns the first record, or <code>default</code> if the result set is empty:</p> <pre><code>row = db.query('SELECT * FROM employees WHERE id = ?', 42).one()\nif row is None:\n    print('Employee not found')\n</code></pre>"},{"location":"records/#scalardefaultnone","title":"<code>scalar(default=None)</code>","text":"<p>Returns the first column of the first row. Ideal for aggregate queries:</p> <pre><code>count = db.query('SELECT COUNT(*) FROM employees').scalar()\nname = db.query('SELECT firstname FROM employees WHERE id = ?', 42).scalar(default='Unknown')\n</code></pre> <p>!!! note     <code>scalar()</code> automatically closes the cursor after reading the value.</p>"},{"location":"records/#table-display","title":"Table Display","text":"<p>When printed, a <code>RecordCollection</code> renders as a formatted table:</p> <pre><code>rows = db.query('SELECT empno, firstname, lastname FROM employees')\nprint(rows)\n</code></pre> <pre><code>empno |firstname|lastname\n------|---------|--------\n000010|CHRISTINE|HAAS\n000020|MICHAEL  |THOMPSON\n</code></pre>"},{"location":"records/#closing-a-recordcollection","title":"Closing a RecordCollection","text":"<p>If you're done with a result set before all rows have been consumed, close it to release the database cursor:</p> <pre><code>rows = db.query('SELECT * FROM large_table')\nfirst = rows[0]\nrows.close()  # Release the cursor\n</code></pre> <p>If all rows have been fetched (via iteration, <code>all()</code>, or indexing past the end), the cursor is closed automatically.</p>"}]}